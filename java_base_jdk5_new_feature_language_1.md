---
title: 2016-4-8未命名文件 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

#程序猿二三事之Java基础--Java SE 5增加的特性--语法篇（一）

[TOC]

##**为什么是Java SE 5？**
目前已经到了JDK-8u74了，JDK7的主版本已经于2015年4月停止公开更新。

那为什么还要来说Java/JDK5呢？

Java SE在1.4（2002）趋于成熟，随着越来越多应用于开发企业应用，许多框架诞生于这个时期或走向成熟。
Java SE 5.0的发布（2004）在语法层面增加了很多特性，让开发更高效，代码更整洁。


	* 自动装箱/拆箱、泛型、注解、for循环增强、枚举、可变参数等新特性让你的小手指少敲了不少代码，可以写更优雅的实现;
	*   API提供并发库大大减少并发编程的难度;
	*   虚拟机层面改进了内存模型，增加虚拟机监控和管理相关的api和工具等等。

但是，<font color=red>语法层面的改变对应于JVM却没有多大变化，只是编译器在编译字节码时偷偷做了手脚。</font>
所以我们应该了解下到底编译器干了啥坏事，有助于写更合理的代码，少踩坑，掉陷阱里也得知道怎么掉的。


另外原因，目前从各种各样的项目代码看，其实多数开发人员常用的还是Java SE 5.0 的特性，甚至习惯用Java SE 1.4及以前的语法特性。
学java也有几年了，许多特性也知道个一二，但是要写下来，还是得查阅不少文章，很多东西欠缺完整性和系统性。
码农写文章（更合理说是整理资料）也是一个学习的过程。

学习一门语言，一旦实际应用于实际开发中，了解背后的原理和理念，深入了解语言的特点，有好处没坏处。


注：javac XXXXX.java  编译命令
      javap -c  XXXXX    反编译命令      
               -c  反编译
               -s  输出内部类型签名  需要看方法签名时  要加上这个参数
               -v  输出附加信息   会输出比较多信息  包括常量表  line number table 等信息， 但没有-s的输出内容  

##**一、自动装箱/拆箱**
####**1、包装类型（存在于Java 1.5之前）**
Java中，类型分成两大类，基本类型（Primitive Type）和引用类型(Reference Type)。
基本类型是内定的，有确定的取值范围，值占有确定的内存空间。
有八大基本类型，分成两个浮点类型（float、double），五个整型(byte, short, int, long，char), 一个布尔型(boolean)。
没看错char也是整型，在语言规范中说明，char是一个16bit无符号整形，用来表示一个UTF-16编码的单元(在Java5中对应Unicode4.0，Java8中对应Unicode6.2)。
基本类型的值不是对象，最基本的对象(Object)方法(toString, hashCode, getClass, equals等)也不能调用。
为了把基本类型当引用类型来用，具备对象的特质，JDK中定义了各种基本类型相对应的包装类。
所谓装箱，就是将基本类型的值包装成(转换-conversion)对应的包装类型的对象，拆箱，就是讲包装类型的对象，转换成基本类型的值。

装箱和拆箱：
``` java
Integer i = 100;
int j = new Integer(250);
```


|基本类型|大小|数值范围|包装类型|默认值|
|--|--|--|--|--|
|boolean|---|true, false|Boolean|false|
|byte|1字节(8bit)|-2^7 -- 2^7-1|Byte|0|
|char|2字节(16bit)|\u0000--\uffff|Character|\u0000|
|short|2字节(16bit)|-2^15 -- 2^15-1|Short|0|
|int|4字节(32bit)|-2^31 -- 2^31-1|Integer|0|
|long|8字节(64bit)|-2^63 -- 2^63-1|Long|0|
|float|4字节(32bit)|IEEE754|Float|0.0f|
|double|8字节(64bit)|IEEE754|Double|0.0d|

####**2、自动装箱/拆箱背后**
